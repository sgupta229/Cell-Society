package model;

import javafx.scene.paint.Color;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.HashMap;
import java.util.Collections;
import java.util.Arrays;

/**
<<<<<<< HEAD
 * This class is responsible for reading config files and parsing the information properly
 * @author Samuel Chan, William Francis, Sahil Gupta
 * @purpose Given a string representing a file in the folder /data, parses the data and constructs the data structure for the simulation
 * @assumptions The file is located in the right location, with the right data format (handles exceptions in case it doesn't)
 * @dependencies Called in SimulationViewer and other subclasses, requires data .csv file to be in /data
 * @usage Construct a new ConfigReader by providing the string of the filename, call the getters for relevant info
 */

public class ConfigReader {
    private String mySimType;
    private String myCellShape;
    private String neighborPolicy;
    private String edgePolicy;
    private String isOutlined;
    private String initialConfig;
    private int myNumStates;
    private Map<Integer, State> myStateMap;
    private int numCols;
    private int numRows;
    public static final int policiesLength = 5;
    public static final int stateObjectsLength = 6;

    private List<Integer> gridData;

    /**
     * constructor of the configuration reader
     * @param s - the csv file name of the config file
     * @purpose Constructs a Configreader for a specified file
     * @assumptions File exists and has correct format
     * @return does not return anything, but use getter/setters for data
     * @param s
     */

    public ConfigReader(String s) {
        gridData = readConfigFile(s + ".csv");
    }

    /**
     * Makes sure file is correct format first, then actually parses the file
     * @param filename
     * @return the List of the data itself, whether generated by the program or parsed from the file
     */
    private List<Integer> readConfigFile(String filename) {

        Scanner input;
        try {
            input = new Scanner(this.getClass().getClassLoader().getResourceAsStream(filename));
            input.useDelimiter(",|\\n");
        } catch (NullPointerException e){
            throw new IllegalArgumentException(filename + " cannot be found", e);
        }

        checkConfigFile(filename);

        return parseFile(input);
    }

    /**
     * Parse the file for relevant data about the simulation
     * @param input
     * @return the griddata
     */
    private List<Integer> parseFile(Scanner input) {
        mySimType = input.next();
        myCellShape = input.next();
        neighborPolicy = input.next();
        edgePolicy = input.next();
        isOutlined = input.next();
        initialConfig = input.next();

        myNumStates = input.nextInt();
        myStateMap = new HashMap<>();
        for (int i = 0; i < myNumStates; i++){
            var name = input.next();
            var type = input.nextInt();
            var colorString = input.next();
            var image = input.next();
            var prob = Double.parseDouble(input.next());
            var amt = input.nextInt();
            State s = new State(name, type, Color.valueOf(colorString), image, prob, amt);
            myStateMap.put(type, s);
        }

        numCols = input.nextInt();
        numRows = input.nextInt();

        checkValid();

        return getResults(input);
    }

    /**
     * Checks to see if the file contains correctly inputted data
     */
    private void checkValid() {
        getSimType();
        getInitialConfig();
        getIsOutlined();
        getEdgePolicy();
        getNeighborPolicy();
        getCellShape();
    }

    // Depending on what kind of way to generate the data, get this data (deterministic: read from file, probabilistic: generate according to probability, totalsum: generate based on specified counts)
    private List<Integer> getResults(Scanner input) {
        List<Integer> results = new ArrayList<>();
        if(initialConfig.equals("DETERMINISTIC")) {
            while (input.hasNext()) {
                results.add(input.nextInt());
            }
        }
        else if (initialConfig.equals("PROBABILISTIC")) {
            double total = 0;
            for(int i = 0; i < myStateMap.size(); i++) {
                total += myStateMap.get(i).getProb();

            }
            if(total != 1.0) {
                throw new IllegalArgumentException("Probabilities don't sum to 1");
            }
            results = generateProb();
        }
        else if (initialConfig.equals("TOTALSUM")) {
            int total = 0;
            for(int i = 0; i < myStateMap.size(); i++) {
                total += myStateMap.get(i).getAmount();

            }
            if(total != numCols*numRows) {
                throw new IllegalArgumentException("Probabilities don't sum to total number of Cells");
            }
            results = generateRandom();
        }
        else {
            throw new IllegalArgumentException("Illegal way of generating grid");
        }

        results.removeAll(Collections.singleton(null));

        if (results.size() != numCols * numRows) {
            throw new IllegalArgumentException("Size of grid created is not equal to total number of cells");
        }

        return results;
    }

    // Ascertain file has correct format for data, throws exceptions
    private void checkConfigFile(String filename) {
        Scanner input;
        try {
            input = new Scanner(this.getClass().getClassLoader().getResourceAsStream(filename));
        } catch (NullPointerException e){
            throw new IllegalArgumentException(filename + " cannot be found", e);
        }
        input.useDelimiter("\\n");
        var sim = input.next();
        var policy = input.next();
        String[] policies = policy.split(",");
        if(policies.length != policiesLength) {
            throw new IllegalArgumentException("Policies Length is not correct");
        }
        var numStates = input.next();
        int num = 0;
        try {
            num = Integer.parseInt(numStates);
        } catch(IllegalArgumentException e) {
            throw new IllegalArgumentException("Num States is not formatted correctly", e);
        }
        for(int i = 0; i < num; i++) {
            var state = input.next();
            String[] stateObjects = state.split(",");
            if(stateObjects.length != stateObjectsLength) {
                throw new IllegalArgumentException("State Objects length is not correct");
            }
            try {
                int intVal = Integer.parseInt(stateObjects[1]);
                if(intVal != i) {
                     throw new IllegalArgumentException("State value must be sequentially assigned");
                }
            } catch(IllegalArgumentException e) {
                throw new IllegalArgumentException("State value is not int correctly", e);
            }
            try {
                Color color = Color.valueOf(stateObjects[2]);
            } catch(IllegalArgumentException e) {
                throw new IllegalArgumentException("State color is not formatted correctly", e);
            }
            try {
                double doubleVal = Double.parseDouble(stateObjects[4]);
            } catch(IllegalArgumentException e) {
                throw new IllegalArgumentException("Probability is not formatted correctly as a double", e);
            }
            try {
                int intVal = Integer.parseInt(stateObjects[5]);
            } catch(IllegalArgumentException e) {
                throw new IllegalArgumentException("Total Sum is not formatted correctly as an int", e);
            }
        }
        var colRows = input.next();
        String[] numColRows = colRows.split(",");
        if(numColRows.length != 2) {
            throw new IllegalArgumentException("Number of values for col/row must be 2");
        }
        try {
            num = Integer.parseInt(numColRows[0]);
        } catch(IllegalArgumentException e) {
            throw new IllegalArgumentException("Row is not formatted correctly as an int", e);
        }
        try {
            num = Integer.parseInt(numColRows[1]);
        } catch(IllegalArgumentException e) {
            throw new IllegalArgumentException("Col is not formatted correctly as an int", e);
        }
    }

    // Generates values based on probabilities given
    private List<Integer> generateProb() {
        Integer[] randArr = new Integer[numCols*numRows];

        int start = 0;
        int end;
        for(int i = 0; i < myStateMap.size(); i++) {
            double prob = myStateMap.get(i).getProb();
            end = (int) (prob * numCols * numRows + start);
            for(int j = start; j < end; j++) {
                if(end > randArr.length) {
                    break;
                }
                randArr[j] = myStateMap.get(i).getType();
            }
            start = end;
        }

        List<Integer> arr  = new ArrayList<>(Arrays.asList(randArr));
        Collections.shuffle(arr);
        return arr;
    }

    // Generates values based on counts given
    private List<Integer> generateRandom() {
        Integer[] randArr = new Integer[numCols*numRows];

        int start = 0;
        int end;
        for(int i = 0; i < myStateMap.size(); i++) {
            int amt = myStateMap.get(i).getAmount();
            end = amt + start;
            for(int j = start; j < end; j++) {
                if(end > randArr.length) {
                    break;
                }
                randArr[j] = myStateMap.get(i).getType();
            }
            start = end;
        }

        List<Integer> arr  = new ArrayList<>(Arrays.asList(randArr));
        Collections.shuffle(arr);
        return arr;
    }

    /**
     * getter method for the number of columns
     * @return int of number of columns
     */

    public int getNumCols() {
        return numCols;
    }

    /**
     * getter method for the number of rows
     * @return the number of rows
     */

    public int getNumRows() {
        return numRows;
    }

    /**
     * get the grid data
     * @return a list of the grid data
     */

    public List<Integer> getGridData() {
        List<Integer> newGrid = new ArrayList<>();
        newGrid.addAll(gridData);
        return newGrid;
    }

    /**
     * gets the simulation type. throws an error if invalid simulation type
     * @return - the simulation type
     */

    public String getSimType() {
        if (mySimType.equals("PREDATORPREY")) {
            return mySimType;
        }
        if (mySimType.equals("FIRE")) {
            return mySimType;
        }
        if (mySimType.equals("GAMEOFLIFE")) {
            return mySimType;
        }
        if (mySimType.equals("PERCOLATION")) {
            return mySimType;
        }
        if (mySimType.equals("ROCKPAPERSCISSORS")) {
            return mySimType;
        }
        if (mySimType.equals("SEGREGATION")) {
            return mySimType;
        }
        else {
            throw new IllegalArgumentException("Simulation type given is invalid");
        }

    }

    /**
     * getter method to get the number of states
     * @return the number of states
     */

    public int getMyNumStates() { return myNumStates; }

    /**
     * getter method for the state map
     * @return the state map
     */

    public Map<Integer, State> getMyStateMap() { return myStateMap; }

    /**
     * converts the config reader data into a string (for error checking)
     * @return a string of the data in the config file
     */

    @Override
    public String toString() {
        return "ConfigReader{" +
                "\nmySimType='" + mySimType + '\'' +
                "\nmyCellShape='" + myCellShape + '\'' +
                "\nneighborPolicy=" + neighborPolicy +
                "\nedgePolicy=" + edgePolicy +
                "\nisOutlined=" + getIsOutlined() +
                "\ninitialConfig=" + initialConfig +
                "\nmyNumStates=" + myNumStates +
                "\nnumCols=" + numCols +
                "\nnumRows=" + numRows +
                "\ngridData=" + gridData +
                '}';
    }

    /**
     * gets the cell shape from the config file
     * @return an int representing the shape
     */

    public int getCellShape() {
        if (myCellShape.equals("TRIANGLE")) {
            return 2;
        }
        if (myCellShape.equals("HEXAGON")) {
            return 1;
        }
        if (myCellShape.equals("SQUARE")) {
            return 0;
        }
        else {
            throw new IllegalArgumentException("Cell Shape given is invalid");
        }
    }

    /**
     * determines the neighbor policy from the config file
     * @return an int representing the neighbor policy
     */

    public int getNeighborPolicy() {
        if (neighborPolicy.equals("DIAGONAL")) {
            return 2;
        }
        if (neighborPolicy.equals("CARDINAL")) {
            return 1;
        }
        if (neighborPolicy.equals("COMPLETE")) {
            return 0;
        }
        else {
            throw new IllegalArgumentException("Neighbor policy given is invalid");
        }
    }

    /**
     * Converts the edge policy specified in the config file to its corresponding integer
     * @return - the integer representing the edge policy
     */

    public int getEdgePolicy() {
        if (edgePolicy.equals("KLEINBOTTLE")) {
            return 2;
        }
        if (edgePolicy.equals("TOROIDAL")) {
            return 1;
        }
        if (edgePolicy.equals("BOUNDED")) {
            return 0;
        }
        else {
            throw new IllegalArgumentException("Edge policy given is invalid");
        }
    }

    /**
     * determines whether or not the grid should be outlined from the config file
     * @return - boolean representing whether or not to outline the cells in the grid
     */

    public boolean getIsOutlined() {
        if (isOutlined.equalsIgnoreCase("TRUE")) {
            return true;
        }
        if (isOutlined.equalsIgnoreCase("FALSE")) {
            return false;
        }
        else {
            throw new IllegalArgumentException("Outlined policy given is invalid");
        }
    }

    /**
     * Get which way the cells will be generated
     * @return - the integer representing the way the cells should be generated
     */

    public int getInitialConfig() {
        if (initialConfig.equals("TOTALSUM")) {
            return 2;
        }
        if (initialConfig.equals("PROBABILISTIC")) {
            return 1;
        }
        if (initialConfig.equals("DETERMINISTIC")) {
            return 0;
        }
        else {
            throw new IllegalArgumentException("Illegal way of generating grid");
        }
    }
}